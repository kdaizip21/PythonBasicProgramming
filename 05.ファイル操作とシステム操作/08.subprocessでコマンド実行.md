※ 本ページはLinux限定。Windowsで利用する際は各自調べること


# `subprocess.run`でコマンド操作

- `subprocess`で`ls -la`を実行する
## 1. 配列でコマンドを渡す形

```python
import subprocess

resutt = subprocess.run(['ls', '-la'])
```

```sh
total 12
drwxr-xr-x  2 kdaizip kdaizip 4096 Jul 27 14:25 .
drwxr-xr-x
22 kdaizip kdaizip 4096 Jul 27 14:26 ..
-rw-r--r--  1 kdaizip kdaizip  181 Jul 27 14:25 study.py
-rw-r--r--  1 kdaizip kdaizip    0 Jul 27 14:19 test.txt
```

## 2. `shell`へ実行するコマンドを渡す形

```python
import subprocess

result = subprocess.run('ls -la', shell=True)
```
```sh
drwxr-xr-x  2 kdaizip kdaizip 4096 Jul 27 14:28 .
drwxr-xr-x 22 kdaizip kdaizip 4096 Jul 27 14:26 ..
-rw-r--r--  1 kdaizip kdaizip  188 Jul 27 14:28 study.py
-rw-r--r--  1 kdaizip kdaizip    0 Jul 27 14:19 test.txt
```

- shellへ渡す場合は`|`の利用も簡単
    ```python
    import subprocess

    result = subprocess.run('ls -la | grep test', shell=True)
    ```
    ```sh
    -rw-r--r-- 1 kdaizip kdaizip    5 Jul 29 08:39 test.txt
    ```



## 3. 実行結果の確認
- `subprocess`は通常、実行した結果がエラーであっても、エラーとして帰ってこない(シェル上ではエラーだが、pythonとしてのエラーではない）
- エラーに対するハンドリングが必要
  - `lsaaaaa`という存在しないコマンドを実行
    ```python
    import subprocess

    result = subprocess.run('lsaaaaa', shell=True)
	```

  - python のエラーではない

    ```sh
    /bin/sh: 1: lsaaaaa: not found
    ```


### 確認方法
#### 1 : `returncode`で実行結果を受け取る
```python
import subprocess

result = subprocess.run('lsaaaaa', shell=True)
print(result.returncode)
```
    

- エラー時は`127`が帰ってくる

    ```sh
    /bin/sh: 1: lsaaaaa: not found
    127
    ```


#### 2 : `cheack = True`オプションをつける
```python
import subprocess

result = subprocess.run('lsaaaaa', shell=True, check=True)
```

- エラーとして帰るので、キャッチすれば良い
    ```sh
    /bin/sh: 1: lsaaaaa: not found
    Traceback (most recent call last):
      File "study.py", line 3, in <module>
        result = subprocess.run('lsaaaaa', shell=True, check=True)
      File "/usr/lib/python3.6/subprocess.py", line 438, in run
        output=stdout, stderr=stderr)
    subprocess.CalledProcessError: Command 'lsaaaaa' returned non-zero exit status 127.
    ```


## 「1. 配列でコマンドを渡す形」でパイプを使う方法

- 非常に分かりづらいが、親プロセス、子プロセス呼び出しで実行する
    ```python
    import subprocess

    p1 = subprocess.Popen(['ls', '-la'], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(
        ['grep', 'test'], stdin=p1.stdout, stdout=subprocess.PIPE)

    p1.stdout.close()
    output = p2.communicate()[0]
    print(output)
    ```
    
    
- 「2.`shell`へ実行するコマンドを渡す形」のほうが簡単
  - だが、セキュリティの問題があるため、上記の親プロセス、子プロセスを記述することを推奨されている
  - 余り使う機会がないのであれば、どちらでも問題はない