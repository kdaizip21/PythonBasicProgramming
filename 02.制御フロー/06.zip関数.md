### こういう場合
- 配列があって
```python
days = ['Mon', 'Tue', 'Wed']
fruits = ['apple', 'banana', 'orange']
drinks = ['coffee', 'tee', 'beer']
```

- それぞれをループして取り出したい
```python
for i in range(len(days)):
    print(days[i], fruits[i], drinks[i])
```
```sh
Mon apple coffee
Tue banana tee
Wed orange beer
```

`i`がいっぱいで見ずらいし、分かりづらい


### zip関数
複数のリストの要素をまとめて取る関数

- 同じ様にzipで取り出す
```python
for day, fruit, drink in zip(days, fruits, drinks):
    print(day, fruit, drink)
```
```sh
Mon apple coffee
Tue banana tee
Wed orange beer
```
見やすい


### 注意
要素の数が違う場合は、多い要素は無視される

- `raspberry`を追加
```python
days = ['Mon', 'Tue', 'Wed']
fruits = ['apple', 'banana', 'orange', 'raspberry']
drinks = ['coffee', 'tee', 'beer']
```

- 同じ処理
```python 
for day, fruit, drink in zip(days, fruits, drinks):
    print(day, fruit, drink)
```

- `rasberry`は出ない
```sh
Mon apple coffee
Tue banana tee
Wed orange beer
```

- 最後まで取り出したい場合は、itertoolsのzip_longest関数を使い、存在しない値を埋めながら取り出すことができる

```python
from itertools import zip_longest


days = ['Mon', 'Tue', 'Wed']
fruits = ['apple', 'banana', 'orange', 'rasberrry']
drinks = ['coffee', 'tee', 'beer', "coffee2", "wine"]


for day, fruit, drink in zip_longest(days, fruits, drinks, fillvalue='N/A'):
    print(day, fruit, drink)

# 出力 ---------
# Mon apple coffee
# Tue banana tee
# Wed orange beer
# N/A rasberrry coffee2
# N/A N/A wine

```