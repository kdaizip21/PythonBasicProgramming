# ジェネレータとは
- 繰り返し処理（イテレーション）を行う際に、全ての要素をメモリ上に展開しないで要素を一つずつ取り出すことができる機能である。
- これにより大規模なデータを扱う際のメモリ使用量を節約できる。ジェネレータは yield 文を使って作成する。

## わかりやすく
- 関数で`return`ではなく`yield`を使うと、pythohがジェネレータと判断する
- `return`と異なり、どこまで処理をしたかを記憶している。
    - for文などのループ処理で、自分が何回目のループかかを記憶している


## 通常の関数とジェネレータの違い

以下の例は、通常の関数でリストを返す例である：

```python
def normal_function():
    return [1, 2, 3, 4, 5]

print(normal_function())
```

出力：

```
[1, 2, 3, 4, 5]
```

この関数は一度に全ての要素をメモリ上に展開して返す。

一方で、ジェネレータでは以下のように `yield` を使用して要素を一つずつ生成する：

```python
def generator_function():
    for i in range(1, 6):
        yield i

for number in generator_function():
    print(number)
```

出力：

```
1
2
3
4
5
```

- ジェネレータでは `yield` が呼ばれる度に一つの値を返し、次に `yield` が呼ばれるまでは実行を停止する。
- 全ての要素を一度に生成するのではなく、要素が必要になる度に一つずつ生成するため、大規模なデータを扱う際にメモリ使用量を節約できる。


## なんでこの処理が必要？
- 処理速度の向上
    - 遅延評価（Lazy Evaluation）：ジェネレータは要素が必要になるまでその生成を遅らせることができる。これにより、必要ない要素の生成を避けることができ、パフォーマンスの向上に寄与する。

- 利用するメモリ（資源）の削減
    - 大量のデータを扱う際にメモリ効率が良い：ジェネレータはイテレーションの過程で一度に一つの要素しかメモリに保持しないため、大量のデータを扱う際にもメモリを節約できる。

- 読みやすい
    - より簡潔なコード：ジェネレータを使うと、リストのようなシーケンス型のデータを生成するコードをより簡潔に書くことができる。