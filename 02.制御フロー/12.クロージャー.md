# クロージャーとは

## とりあえず
- 分かりづらい 
- 使い所がイメージしにくい

実際に使われているソースコードを見ると、何やってるのか本気で理解できないため、    
ここでは大体のイメージができ、読めることを目標にする    
    
自分で意図的に書く必要はないが、書けると良い





## クロージャーとは

* クロージャーは、関数とその関数が作成された環境（レキシカルスコープ）をキャプチャしたものを指します。
  これにより、関数は外部スコープで定義された変数にアクセスすることができます。
  これがクロージャーの主な特徴であり、その強力な機能性を提供します。

* 一般的な関数とクロージャーの違いは、クロージャーが定義された時点での自由変数（ローカルではない、でもグローバルでもない変数）のバインディングを保持し、その後もそれらの変数にアクセスできるという点です。


### 普通に関数を使う

- ある関数内関数（インナー関数）を持つ関数がある

```python
def outer(a, b):
    
    def inner():
        return a + b
    
    return inner()
```
- 普通に実行する
```python
print(outer(2, 3))
```
```sh
5
```
とくに問題はない

### これをクロージャーにする
```python
def outer(a, b):
    
    def inner():
        return a + b
    
    return inner
```
- とくに違いはない。様に見えるが、よくみると
- `return inner`のinnerに`()`がない
- これがクロージャー

- これを実行する
```python
print(outer(2, 3))
```
```sh
<function outer.<locals>.inner at 0x000001581F7AD048>
```

- ***オブジェクトとして持っている*** 
- ***関数自体は実行されていない***



### どうやって使う？
```python
def outer(a, b):
    def inner():
        return a + b

    return inner


# オブジェクトを呼び出して
result = outer(2, 3)

# 関数として実行する
# ここで初めて実行される
r = result()
print(r)
```
```sh
5
```


### なんで？
1. outer(2, 3)を実行しても、関数としては動作しない
2. ただし、2、3という数値が入ったことは記憶している
3. r=result()が実行されたときは、記憶した2, 3を使う


### だから？
- 関数に初期値を与えた状態で、関数を実行することができる


## 具体的な例
- クロージャーの一つの用途は、特定の値を"覚えて"それを基に計算を行う関数を作ること
- 以下に円の面積を求めることをクロージャーで書く

1. 円の面積：半径×半径×πを計算する
2. πはそれぞれの値で実行したい
    - 3.14
    - 3
    - 3.131592
    
    
- クロージャーを用意
```python
# アウター関数でπを受け取る
def circle_area_func(pi):

    # π × 半径 × 半径
    def circle_area(radius):
        return pi * radius * radius
    
    return  circle_area
```
- 計算する
```python 
# それぞれのπの値を設定する
area1 = circle_area_func(3.14)
area2 = circle_area_func(3)
area3 = circle_area_func(3.131592)

# 半径10 でそれぞれのπで計算する
print(area1(10))
print(area2(10))
print(area3(10))
```
- 結果
```
314.0
300
313.1592
```



## 具体的な例２
1. 底辺×高さを計算する
2. 高さは10で固定する
3. 底辺を
    - 25
    - 35

```python 
# クロージャーは 2. → 3.の順番
# 固定する値をアウターにして
# 変化する値をインナーに設定する


def area_cal_func(width):
    def area_cal(height):
        return width * height

    return area_cal
```
```python
# 実行は3. → 2.の順番

# 先に変化する値を入れて
ac1 = area_cal_func(25)
ac2 = area_cal_func(35)

# 次に固定する値を入れる
print(ac1(10))
print(ac2(10))
```

```
250
350
```




## 最終的にメリットは
- 普通の関数でも書ける
- けど高速化、資源（メモリ）を削減できる

1. たくさん呼び出される
2. 使う際にグローバル変数を（それなりに）使う関数である

場合にメリットが出てくる




